The return Statement in JavaScript : A Detailed Explanation
The return statement is a fundamental part of JavaScript functions that specifies the value to be returned from that function. Let's explore it in depth.

Basic Syntax
  
return [expression];
The expression is optional. If omitted, the function returns undefined.

How It Works
Terminates Function Execution: When a return statement is encountered, the function stops executing immediately.

  
function example() {
  console.log("This will run");
  return;
  console.log("This won't run");
}

Returns a Value: The return statement sends a value back to the caller.

function add(a, b) {
  return a + b;
}
const sum = add(2, 3); // sum is now 5

Multiple Returns: A function can have multiple return statements, but only one will execute.

function checkNumber(num) {
  if (num > 0) return "Positive";
  if (num < 0) return "Negative";
  return "Zero";
}

Key Behaviors
Implicit undefined Return
If a function doesn't have a return statement, or if the return has no expression, it returns undefined.

function noReturn() {
  // does something
}
console.log(noReturn()); // undefined

Return and Hoisting
The return statement itself isn't hoisted, but the function declaration is:

console.log(myFunc()); // Works because function is hoisted
function myFunc() { return "Hello"; }

Understanding the Statement
When we say "The return statement itself isn't hoisted, but the function declaration is," we're describing two distinct behaviors in JavaScript's compilation phase:

1. Function Declaration Hoisting
Function declarations are hoisted to the top of their containing scope during compilation. This means the entire function (including its name and body) is available before its actual position in the code.

// This works because the function is hoisted
console.log(greet()); // "Hello"

function greet() {
  return "Hello";
}


2. Return Statement Behavior
The return statement itself is not hoisted independently. It only executes when the function is called and execution reaches that point in the code.

function example() {
  // The return statement below isn't "moved up" by itself
  // It stays in place and executes when reached
  return "Value";
}

How It Works Internally
During compilation phase:

The JavaScript engine scans for function declarations and hoists them

All other code (including return statements) remains in place

During execution phase:

When a function is called, execution starts at the top of the function body

The return statement only takes effect when execution reaches it


Practical Implications
Correct Usage (Works)

// Works because the entire function is hoisted
console.log(square(5)); // 25

function square(n) {
  return n * n;
}

Incorrect Assumption (Doesn't Work)

function test() {
  // People might think the return is hoisted above the console.log
  console.log("This will still run");
  return;
  console.log("This won't run");
}
// The return only affects execution flow when reached
test(); // Logs "This will still run"

Contrast with Function Expressions

// Doesn't work because function expressions aren't hoisted
console.log(square(5)); // Error: square is not defined

const square = function(n) {
  return n * n;
};