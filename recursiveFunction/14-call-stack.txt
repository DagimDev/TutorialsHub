What Is the Call Stack in JavaScript?

The call stack is a data structure that JavaScript uses to keep track of function execution. It follows the Last-In, First-Out (LIFO) principle.

The call stack is a fundamental mechanism JavaScript uses to track function execution. Let me break it down clearly with examples relevant to your Merge Sort questions.

The call stack is:

A LIFO (Last-In, First-Out) data structure that tracks function calls

JavaScript's "to-do list" of functions that need to be executed

Where the engine stores execution contexts (variable environments)

How It Works

When a function is invoked, it's added ("pushed") onto the top of the call stack.

When the function completes, it's removed ("popped") from the stack.

The browser's JavaScript engine uses the call stack to manage the order in which functions are run.


üß† Visual Example:

function greet() {
  console.log("Hello");
  sayBye();
}

function sayBye() {
  console.log("Goodbye");
}

greet();

Call Stack Flow:

Call Stack:
1. greet() ‚Üí pushed
2. sayBye() ‚Üí pushed (inside greet)
3. sayBye() ‚Üí popped (finished)
4. greet() ‚Üí popped (finished)

Output:  Hello
         Goodbye

function greet() {
  console.log("Hello!");
}

function sayName() {
  greet();
  console.log("John");
}

sayName();
Call Stack Flow:

sayName() is pushed to stack

greet() is pushed when called inside sayName

greet() executes ("Hello!" logs), then pops off

sayName() continues, logs "John", then pops off

Stack is empty

[Top of Stack]
greet()       ‚îÇ
sayName()     ‚îÇ ‚Üê Bottom of Stack

üîÅ Call Stack in Recursion

With recursion, each recursive call is a new function frame pushed onto the stack.

Example:

function countDown(n) {
  if (n === 0) return;
  console.log(n);
  countDown(n - 1);
}

countDown(3);

Stack Trace:

countDown(3) ‚Üí pushed
countDown(2) ‚Üí pushed
countDown(1) ‚Üí pushed
countDown(0) ‚Üí pushed
countDown(0) ‚Üí popped
countDown(1) ‚Üí popped
countDown(2) ‚Üí popped
countDown(3) ‚Üí popped
